# Desafio 005: Validador de CPF em JavaScript

## Cen√°rio

Em qualquer sistema brasileiro que lida com dados de usu√°rios, a valida√ß√£o de um CPF √© uma rotina essencial. Ela previne erros de digita√ß√£o e a inser√ß√£o de dados claramente inv√°lidos no sistema, garantindo uma maior integridade dos dados. Sua tarefa √© criar a l√≥gica de valida√ß√£o que poderia ser usada tanto no backend (Node.js) quanto no frontend.

## üéØ Objetivo do Desafio

Desenvolver uma fun√ß√£o em JavaScript chamada `validarCPF` que recebe uma `string` contendo um CPF e retorna `true` se o CPF for v√°lido e `false` caso contr√°rio.

## üìã Requisitos (A L√≥gica de Valida√ß√£o)

Um CPF √© considerado v√°lido se passar por todas as etapas a seguir:

1.  **Limpeza:** A fun√ß√£o deve primeiro remover todos os caracteres n√£o num√©ricos. Um CPF como `"123.456.789-00"` deve se tornar `"12345678900"`.

2.  **Valida√ß√µes Iniciais:**
    * A string limpa deve ter **exatamente 11 d√≠gitos**. Se tiver mais ou menos, √© inv√°lida.
    * Deve-se verificar se todos os d√≠gitos s√£o iguais (ex: "11111111111"). Se forem, o CPF √© considerado inv√°lido.

3.  **C√°lculo do Primeiro D√≠gito Verificador (o 10¬∫ d√≠gito):**
    * Pegue os 9 primeiros d√≠gitos do CPF.
    * Multiplique cada um por um peso, come√ßando em 10 e diminuindo at√© 2 (o primeiro d√≠gito por 10, o segundo por 9, e assim por diante).
    * Some todos os resultados dessas multiplica√ß√µes.
    * Calcule o resto da divis√£o dessa soma por 11 (`resto = soma % 11`).
    * O d√≠gito verificador ser√° `11 - resto`. Se o resultado for 10 ou 11, o d√≠gito √© `0`.
    * Compare o d√≠gito calculado com o 10¬∫ d√≠gito do CPF. Se forem diferentes, o CPF √© inv√°lido.

4.  **C√°lculo do Segundo D√≠gito Verificador (o 11¬∫ d√≠gito):**
    * Pegue os 10 primeiros d√≠gitos do CPF (incluindo o primeiro d√≠gito verificador que voc√™ acabou de validar).
    * Multiplique cada um por um peso, come√ßando em 11 e diminuindo at√© 2.
    * Repita o mesmo processo de soma, c√°lculo do resto da divis√£o por 11 e c√°lculo do d√≠gito final.
    * Compare o d√≠gito calculado com o 11¬∫ d√≠gito do CPF. Se forem diferentes, o CPF √© inv√°lido.

5.  **Resultado Final:**
    * Se o CPF passar por todas as verifica√ß√µes acima, a fun√ß√£o deve retornar `true`.

## ‚úÖ Exemplos para Testar

| Entrada | Sa√≠da Esperada | Motivo |
| :--- | :--- | :--- |
| `"111.444.777-05"` | `true` | CPF v√°lido |
| `"000.000.000-00"` | `false` | Todos os d√≠gitos s√£o iguais |
| `"123.456.789-00"` | `false`| D√≠gitos verificadores incorretos |
| `"123456789"` | `false`| Menos de 11 d√≠gitos |

## ‚≠ê Ponto de B√¥nus

Transforme seu script em um pequeno m√≥dulo Node.js que exporta a fun√ß√£o `validarCPF` (`module.exports = validarCPF;`). Crie um arquivo de teste separado (`teste.js`) que importa a fun√ß√£o (`require('./validador.js')`) e a testa com v√°rios CPFs, imprimindo os resultados no console.

## üí° Dicas (Opcional)

<details>
  <summary>Clique para ver as dicas</summary>
  
  * **Limpeza:** Em JavaScript, `cpf.replace(/\D/g, '')` √© uma forma muito eficiente com Express√µes Regulares de remover tudo que n√£o for d√≠gito.
  * **Convers√£o:** Lembre-se de converter os caracteres da string para n√∫meros antes de fazer os c√°lculos matem√°ticos. `parseInt()` ou `Number()` funcionam bem.
  * **C√°lculo:** O algoritmo pode parecer complexo, mas implemente-o passo a passo. Crie uma fun√ß√£o auxiliar para o c√°lculo do d√≠gito, j√° que a l√≥gica se repete.

</details>